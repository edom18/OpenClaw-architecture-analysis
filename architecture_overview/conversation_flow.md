# 会話フローとターン管理

このドキュメントでは、OpenClawがユーザーとAI間の対話ループをどのように処理するかを説明します。

## 1. 最初のユーザープロンプト
ユーザーがメッセージを送信すると、それがセッション履歴（Transcript）に追加されます。その後、エージェントランナーが起動します。

## 2. ターンベースの実行 (`src/agents/pi-embedded-subscribe.ts`)
OpenClawは、1つの論理的なリクエスト内でマルチターン（複数回のやり取り）をサポートしています（例：ユーザーが「バグを直して」と言ったとき、エージェントが回答する前に複数のツール呼び出しを行う場合など）。

### サブスクライバーパターン
`subscribeEmbeddedPiSession` は、エージェントコアからのイベントを監視します：
- **`text_delta`**: ストリーミングテキスト出力を処理します。
- **`tool_call`**: ツールの実行要求をインターセプトします。ツールを実行し、その結果をエージェントにフィードバックします。
- **`message_end`**: アシスタントのターンの終了をマークします。

### ツール実行ループ
1. エージェントが `tool_call` を発行。
2. OpenClawがツールを実行（ファイルの検索、シェルコマンドの実行など）。
3. 結果が `tool_result` として履歴に追加される。
4. エージェントが再び呼び出され、結果を観察して次のステップを決定する。

## 3. 状態の永続化
- **セッション履歴**: すべてのメッセージ（ユーザー、アシスタント、ツール結果）はJSONセッションファイルに保存されます（場所：`~/.openclaw/sessions/` またはエージェントのステートディレクトリ）。
- **履歴管理**: コンテキストウィンドウのオーバーフローを防ぐため、OpenClawは「コンパクション（履歴の要約）」を実行したり、LLMに送り返すターンの数を制限したりします。

## 4. 更新の内容とタイミング
- **システムプロンプト**: LLMへのリクエストごと（毎ターン）に再評価されます。
- **コンテキストの挿入**: ターン中に「プロジェクトコンテキスト」に影響を与える新しいファイルが作成または変更された場合、更新されます。
- **ツール概要**: プラグインが読み込まれたり無効化されたりした場合にリフレッシュされます。
